#!/usr/bin/env python3
"""
Dolphin SLAM - 局部视觉细胞 ROS2 节点
管理视觉模板和场景识别
"""

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from std_msgs.msg import Header, Float32MultiArray
from visualization_msgs.msg import Marker, MarkerArray
from cv_bridge import CvBridge
import numpy as np
import os
from typing import Optional, List
import pickle

# 导入核心模块
from dolphin_slam.local_view_cells import LocalViewCells

# 导入自定义消息（需要先生成）
# from dolphin_slam.msg import Descriptors, LocalViewMatch

class LocalViewNode(Node):
    """局部视觉细胞 ROS2 节点"""
    
    def __init__(self):
        super().__init__('local_view_node')
        
        # 声明参数
        self.declare_parameters(
            namespace='',
            parameters=[
                ('matching_algorithm', 'fabmap'),
                ('similarity_threshold', 0.65),
                ('vocabulary_size', 1000),
                ('max_templates', 5000),
                ('template_decay_rate', 0.995),
                ('descriptors_topic', '/features/descriptors'),
                ('matches_topic', '/local_view/matches'),
                ('vocabulary_path', ''),
                ('save_interval', 100),  # 每N个模板保存一次
            ]
        )
        
        # 获取参数
        self.matching_algorithm = self.get_parameter('matching_algorithm').value
        self.similarity_threshold = self.get_parameter('similarity_threshold').value
        self.vocabulary_size = self.get_parameter('vocabulary_size').value
        self.max_templates = self.get_parameter('max_templates').value
        self.template_decay_rate = self.get_parameter('template_decay_rate').value
        self.vocabulary_path = self.get_parameter('vocabulary_path').value
        self.save_interval = self.get_parameter('save_interval').value
        
        # 初始化局部视觉细胞
        self.local_view = LocalViewCells(
            matching_algorithm=self.matching_algorithm,
            similarity_threshold=self.similarity_threshold,
            vocabulary_size=self.vocabulary_size,
            max_templates=self.max_templates,
            template_decay_rate=self.template_decay_rate
        )
        
        # CV Bridge
        self.bridge = CvBridge()
        
        # 计数器
        self.descriptor_count = 0
        self.match_count = 0
        
        # 训练数据收集
        self.training_descriptors = []
        self.is_training = False
        
        # 订阅者
        self.descriptors_sub = self.create_subscription(
            Image,  # 临时使用 Image 消息传输描述符
            self.get_parameter('descriptors_topic').value,
            self.descriptors_callback,
            10
        )
        
        # 发布者
        # 匹配结果（简化版，使用 Float32MultiArray）
        self.match_pub = self.create_publisher(
            Float32MultiArray,
            self.get_parameter('matches_topic').value,
            10
        )
        
        # 模板活动可视化
        self.template_activity_pub = self.create_publisher(
            MarkerArray,
            '/local_view/template_activity',
            10
        )
        
        # 统计信息
        self.stats_pub = self.create_publisher(
            MarkerArray,
            '/local_view/statistics',
            10
        )
        
        # 服务
        self.train_vocab_srv = self.create_service(
            'std_srvs/srv/Trigger',
            '/local_view/train_vocabulary',
            self.train_vocabulary_callback
        )
        
        self.save_vocab_srv = self.create_service(
            'std_srvs/srv/Trigger',
            '/local_view/save_vocabulary',
            self.save_vocabulary_callback
        )
        
        # 定时器
        self.viz_timer = self.create_timer(1.0, self.publish_visualizations)
        self.stats_timer = self.create_timer(5.0, self.publish_statistics)
        
        # 尝试加载词汇表
        if self.vocabulary_path and os.path.exists(self.vocabulary_path):
            self.load_vocabulary()
            
        self.get_logger().info(f'局部视觉细胞节点已启动，使用 {self.matching_algorithm} 算法')
        
    def descriptors_callback(self, msg: Image):
        """处理描述符输入"""
        try:
            # 从 Image 消息解码描述符（临时方案）
            if msg.encoding == '32FC1':
                data = np.frombuffer(msg.data, dtype=np.float32)
                descriptors = data.reshape(msg.height, msg.width)
            else:
                self.get_logger().warning(f'不支持的描述符编码: {msg.encoding}')
                return
                
            self.descriptor_count += 1
            
            # 如果正在训练，收集描述符
            if self.is_training:
                self.training_descriptors.append(descriptors)
                self.get_logger().info(f'收集训练描述符 {len(self.training_descriptors)}')
                return
                
            # 如果没有词汇表，无法匹配
            if self.local_view.vocabulary is None:
                self.get_logger().warning('词汇表未加载，无法进行匹配')
                return
                
            # 查找匹配
            template_id, similarity = self.local_view.find_match(descriptors)
            
            if template_id is not None:
                # 发布匹配结果
                self.publish_match(template_id, similarity, msg.header)
                self.match_count += 1
                self.get_logger().debug(f'找到匹配: 模板 #{template_id}, 相似度: {similarity:.3f}')
            else:
                # 创建新模板
                new_template_id = self.local_view.add_template(descriptors)
                self.publish_match(new_template_id, 1.0, msg.header)
                self.get_logger().info(f'创建新模板 #{new_template_id}')
                
                # 定期保存
                if new_template_id % self.save_interval == 0:
                    self.save_templates()
                    
        except Exception as e:
            self.get_logger().error(f'处理描述符时出错: {e}')
            
    def publish_match(self, template_id: int, similarity: float, header: Header):
        """发布匹配结果"""
        # 使用 Float32MultiArray 临时代替自定义消息
        msg = Float32MultiArray()
        msg.data = [
            float(template_id),
            similarity,
            float(self.descriptor_count),
            float(len(self.local_view.templates))
        ]
        
        self.match_pub.publish(msg)
        
    def publish_visualizations(self):
        """发布可视化数据"""
        if not self.local_view.templates:
            return
            
        marker_array = MarkerArray()
        
        # 获取最活跃的模板
        active_templates = self.local_view.get_active_templates(top_k=20)
        
        for i, (template_id, activation) in enumerate(active_templates):
            marker = Marker()
            marker.header.frame_id = "map"
            marker.header.stamp = self.get_clock().now().to_msg()
            marker.ns = "template_activity"
            marker.id = template_id
            marker.type = Marker.CYLINDER
            marker.action = Marker.ADD
            
            # 位置（简化：使用模板 ID 作为位置）
            marker.pose.position.x = (template_id % 10) * 2.0
            marker.pose.position.y = (template_id // 10) * 2.0
            marker.pose.position.z = activation * 5.0  # 高度表示激活强度
            marker.pose.orientation.w = 1.0
            
            # 大小
            marker.scale.x = 1.5
            marker.scale.y = 1.5
            marker.scale.z = activation * 10.0
            
            # 颜色（根据激活强度）
            marker.color.r = activation
            marker.color.g = 1.0 - activation
            marker.color.b = 0.0
            marker.color.a = 0.7
            
            marker.lifetime = rclpy.duration.Duration(seconds=2.0).to_msg()
            
            marker_array.markers.append(marker)
            
        self.template_activity_pub.publish(marker_array)
        
    def publish_statistics(self):
        """发布统计信息"""
        stats = self.local_view.get_statistics()
        
        marker_array = MarkerArray()
        
        # 创建文本标记显示统计信息
        marker = Marker()
        marker.header.frame_id = "map"
        marker.header.stamp = self.get_clock().now().to_msg()
        marker.ns = "statistics"
        marker.id = 0
        marker.type = Marker.TEXT_VIEW_FACING
        marker.action = Marker.ADD
        
        marker.pose.position.x = 0.0
        marker.pose.position.y = 0.0
        marker.pose.position.z = 10.0
        marker.pose.orientation.w = 1.0
        
        marker.scale.z = 1.0
        
        marker.color.r = 1.0
        marker.color.g = 1.0
        marker.color.b = 1.0
        marker.color.a = 1.0
        
        # 统计文本
        marker.text = (
            f"局部视觉细胞统计\n"
            f"================\n"
            f"模板总数: {stats['total_templates']}\n"
            f"总比较次数: {stats['total_comparisons']}\n"
            f"成功匹配: {stats['successful_matches']}\n"
            f"匹配率: {stats['match_rate']:.2%}\n"
            f"当前模板: {stats['current_template']}\n"
            f"词汇表大小: {stats['vocabulary_size']}"
        )
        
        marker_array.markers.append(marker)
        self.stats_pub.publish(marker_array)
        
        # 同时输出到日志
        self.get_logger().info(
            f"LV 统计 - 模板: {stats['total_templates']}, "
            f"匹配率: {stats['match_rate']:.2%}"
        )
        
    def train_vocabulary_callback(self, request, response):
        """训练词汇表服务回调"""
        if self.is_training:
            response.success = False
            response.message = "已经在训练中"
            return response
            
        # 开始收集训练数据
        self.is_training = True
        self.training_descriptors = []
        
        # 创建定时器来检查训练进度
        def check_training():
            if len(self.training_descriptors) >= 100:  # 收集足够的描述符
                self.get_logger().info("开始训练词汇表...")
                try:
                    self.local_view.train_vocabulary(self.training_descriptors)
                    self.is_training = False
                    self.get_logger().info("词汇表训练完成")
                except Exception as e:
                    self.get_logger().error(f"训练失败: {e}")
                    
        self.create_timer(10.0, check_training)  # 10秒后检查
        
        response.success = True
        response.message = "开始收集训练数据"
        return response
        
    def save_vocabulary_callback(self, request, response):
        """保存词汇表服务回调"""
        try:
            if self.vocabulary_path:
                vocab_file = os.path.join(self.vocabulary_path, 'vocabulary.npy')
                self.local_view.save_vocabulary(vocab_file)
                response.success = True
                response.message = f"词汇表已保存到 {vocab_file}"
            else:
                response.success = False
                response.message = "词汇表路径未设置"
        except Exception as e:
            response.success = False
            response.message = f"保存失败: {e}"
            
        return response
        
    def load_vocabulary(self):
        """加载词汇表"""
        try:
            vocab_file = os.path.join(self.vocabulary_path, 'vocabulary.npy')
            if os.path.exists(vocab_file):
                self.local_view.load_vocabulary(vocab_file)
                self.get_logger().info(f"词汇表已从 {vocab_file} 加载")
            else:
                self.get_logger().warning(f"词汇表文件不存在: {vocab_file}")
        except Exception as e:
            self.get_logger().error(f"加载词汇表失败: {e}")
            
    def save_templates(self):
        """保存模板数据库"""
        try:
            if self.vocabulary_path:
                templates_file = os.path.join(self.vocabulary_path, 'templates.pkl')
                with open(templates_file, 'wb') as f:
                    pickle.dump({
                        'templates': self.local_view.templates,
                        'next_template_id': self.local_view.next_template_id,
                        'activation_history': list(self.local_view.activation_history)
                    }, f)
                self.get_logger().info(f"模板已保存到 {templates_file}")
        except Exception as e:
            self.get_logger().error(f"保存模板失败: {e}")

def main(args=None):
    rclpy.init(args=args)
    
    try:
        node = LocalViewNode()
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f'错误: {e}')
    finally:
        if rclpy.ok():
            rclpy.shutdown()

if __name__ == '__main__':
    main()
